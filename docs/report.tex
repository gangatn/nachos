\documentclass{report}

% PACKAGES
\usepackage[utf8]{inputenc}
% --

\title{NachOS Rapport}
\author{
}
\begin{document}
\maketitle

\tableofcontents
\chapter{Fonctionnalités}

Cette version de NachOS, a été étendu en mettant principalement l'accent sur la gestion des processus et le système de fichier.

Chaque programme utilisateur peut lancer des forks et des execs de façon indépendante, mais aussi de façon performante grâce à la technique du copy-on-write.

Le système de fichier propose une façon plus créative de gérer les fichiers grâce à des étiquettes (appelées ``tag'' par la suite). Ce système permet un accès direct aux fichiers sans avoir à passer par une hiérarchie comme sous les systèmes de fichiers de type POSIX.

De façon plus classique, le système dispose d'une console synchrone et de la gestion des processus légers (threads).

\chapter{Spécifications}

\section{Appels systèmes de base}

\begin{verbatim}
void Halt();
\end{verbatim}
Arrête le système.

\begin{verbatim}
void  Exit(int status);
\end{verbatim}
Termine le processus courant.
\section{Entrées/Sorties}

\subsection{Appels systèmes}

\begin{verbatim}
void PutChar( char c  );
\end{verbatim}
Écrirt un caractère sur la sortie standard. Cet appel est bloquant.

\begin{verbatim}
void PutString( char *str  );
\end{verbatim}
Écrirt la chaine de caractère donné en paramètre sur la sortie standard. Cet appel est bloquant.

\begin{verbatim}
int GetChar ( );
\end{verbatim}
Lit un caractère sur l'entrée standard. Cet appel est bloquant. La valeur retournée est de type int afin de ne pas confontre la valeur 255 (ÿ) d'un char avec -1 (EOF);

\begin{verbatim}
void GetString( char *s, int n  );
\end{verbatim}
Lit une chaine de caractère dans un buffer de taille donnée sur l'entrée standard. La lecture s'arrête lorsque la taille du buffer est atteinte ou que les caractères '\0' ou '\n' sont rencontrés ou que la fin de fichier est atteinte. Le caractère '\n' est conservé dans la chaine. Force l'écriture du caractère '\0' en fin de chaine (à la fin du buffer dans le pire cas). Cet appel est bloquant.

\begin{verbatim}
void PutInt( int n );
\end{verbatim}
Permet d'écrire un entier "n" sur la sortie standard. Cette appel est bloquant.


\begin{verbatim}
void GetInt( int *n  );
\end{verbatim}
Permet de lire un entier  "n" depuis l'entrée standard. Cette appel est bloquant.

\section{Threads utilisateurs}
Le système de threads actuel permet de créer des threads quelque soit le thread appelant grâce à l'appel système UserThreadCreate().Il n'y a pas de lien de parenté : chaque threads peut donc attendre la terminaison d'un autre thread appartenant au même processus grâce à l'appel système UserThreadJoin(). Dans le cas d'une tentative d'attente sur un thread déjà terminé ou sur un thread non connu, la fonction retourne directement, sans effet de bord.

\subsection{Appels systèmes}

\begin{verbatim}
int UserThreadCreate ( void (*f)(void*), void* arg  );
\end{verbatim}
Crée un thread qui execute la fonction "f" avec l'argument "arg". Retourne l'id du thread dans le processus appelant. Pour l'instant, aucune erreur n'est retournée. Nous prevoyons de renvoyer une erreur dans le cas ou il n'y a plus de place dans l'espace réservée pour la pile utilisateur.

\begin{verbatim}
void UserThreadExit(  );
\end{verbatim}
Termine le thread courant.

\begin{verbatim}
void UserThreadJoin( int tid  );
\end{verbatim}
Attend la terminaison du thread avec le tid donnée.Cet appel est bloquant tant que le thread attendu n'est pas terminé.  Un appel à UserThreadJoin avec le tid du thread appelant retourne immédiatement, il n'y a pas d'effet de bord. Dans le cas où le tid ne correspond à aucun thread, la fonction retourne immédiatement. 

\section{Processus utilisateurs}
\subsection{Appels systèmes}

\begin{verbatim}
int Fork ( );
\end{verbatim}
Crée un nouveau processus en dupliquant le processus appelant. Dans le processus père, le pid du processus fils est retourné. Dans le processus fils, 0 est retourné. 
Il n'y a pour le moment, pas de gestion d'erreur.

\begin{verbatim}
int Exec ( char *s  );
\end{verbatim}
Remplace le processus appelant par un nouveau processus. Ce nouveau processus représente un programme dont le chemin est donnée en paramètre.
Cette fonction retourne -1 dans le cas ou l'executable n'a pas pu être chargé. Elle ne retourne ne rien sinon. Les autres cas d'erreur seront traité ultérieurement. 

\begin{verbatim}
int ForkExec ( char *filename  );
\end{verbatim}
Crée un nouveau processus à partir du programme donné et l'execute. Le pid du processus créé est retourné dans le père.
Le père continue ensuite son exécution en parrallèle.

\chapter{Implantation}
\section{Entrées/Sorties}
Une Console synchrone a été développé. Elle permet par le biais d'appels systèmes d'écrire ou de lire au choix : 

\begin{itemize}
\item Un caractère
\item Une chaîne de caractère
\item Un entier
\end{itemize}

Pour plus de souplesse, la machine a été modifié afin de faire la distinction entre le symbole EOF et le caractère 'ÿ'.

\section{Multithreadings}
A la création d'un thread, un nouvel identifiant (tid) lui est assigné. Le problème est qu'en se contentant d'incrémenter un compteur représentant le prochain tid à attribuer, on peut arriver très vite à un dépassement d'entier. Pour éviter cela, à chaque libération d'un tid par un thread, ce tid est mis dans une liste dans lequel les prochains threads créés viendront récupérer un tid si la liste n'est pas vide.
Ce thread est ensuite ajouté dans la liste des threads courant du processus et l'espace d'adressage du processus lui est partagé.

Pour attendre un thread, un parcours de la liste des threads est effectué jusqu'à trouver le thread avec le tid passé en paramètre. Chaque thread possédant un sémaphore, le thread voulant attendre n'a plus qu'à prendre un jeton sur le sémaphore associé (qui devient alors bloquant). Le tid est alors remis dans la liste des tids disponible.

A chaque fois qu'un thread se termine, il est marqué comme devant être détruit et un appel à Sleep() est effectué.
L'ordonnanceur s'occupe alors de détruire le thread et l'espace d'adressage qui lui associé, la prochaine fois où celui-ci devra être lancé.

Lorsque plusieurs attentes (join) sont fait sur le même thread depuis des threads différents, le résultat est indéterminé. Cela est dû au fait que le premier thread qui se réveil va effacer ensuite la référence dans la liste des threads du processus, ce qui rendra l'utilisation de cet référence invalide dans les autres threads.

\section{Mémoire virtuelle}
\section{Gestion des fichiers}
\section{Réseaux}

\chapter{Tests utilisateurs}

Programmes de test des threads :

\begin{itemize}
  \item testthreads : programme créant des threads et les attend
  \item testthreads\_nojoin : programme créant des threads et qui ne les attend pas
  \item testthreads\_noexit : programme créant des threads qui ne font pas d'appels à l'appel
  système UserThreadExit
  \item testthreadsinthreads : programme créant des threads qui créent des threads
  
\end{itemize}

Programmes de test des processus :

\begin{itemize}
  \item testfork : programme créant un processus
  \item testexec : programme appelant Exec
  \item testforkandexec : programme créant un processus qui remplace son contexte par celui d'un autre programme avec l'appel à Exec
  \item testforkexec : programme créant un processus avec le contexte d'un autre programme avec l'appel à ForkExec
\end{itemize}

\chapter{Développement du projet}

\section{Notes de développement}

\begin{itemize}
  \item Les processus créés ne sont pas attendus par le père. L'implémentation d'un Wait reste à faire.
  \item Lors d'un appel système Exit, les threads doivent être arrêtés
  \item Un système de macro permettant de générer les syscalls
\end{itemize}


\end{document}
